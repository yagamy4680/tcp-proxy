// Generated by LiveScript 1.2.0
(function(){
  var net, events, colors, optimist, bunyan, bunyanDebugStream, async, moment, sprintf, DBG, INFO, ERR, BaseServer, DataServer, MonitorServer, main;
  net = require('net');
  events = require('events');
  colors = require('colors');
  optimist = require('optimist');
  bunyan = require('bunyan');
  bunyanDebugStream = require('bunyan-debug-stream');
  async = require('async');
  moment = require('moment');
  sprintf = require('sprintf-js').sprintf;
  DBG = function(){
    return global.logger.debug.apply(global.logger, arguments);
  };
  INFO = function(){
    return global.logger.info.apply(global.logger, arguments);
  };
  ERR = function(){
    return global.logger.error.apply(global.logger, arguments);
  };
  BaseServer = (function(){
    BaseServer.displayName = 'BaseServer';
    var prototype = BaseServer.prototype, constructor = BaseServer;
    function BaseServer(port){
      this.port = port;
      DBG("enter");
      this.sockets = [];
      this.ee = new events.EventEmitter();
    }
    prototype.startup = function(){
      var self, port, connectCB, opts, server;
      self = this;
      port = this.port;
      connectCB = function(){
        return self.onConnect.apply(self, arguments);
      };
      opts = {
        allowHalfOpen: false,
        pauseOnConnect: false
      };
      server = this.server = net.createServer(opts, connectCB);
      return server.listen(port, function(err){
        if (err != null) {
          return ERR("failed to listen port " + port + ", err: " + err);
        }
        return INFO("listening " + port);
      });
    };
    prototype.writeAll = function(data, callback){
      var f;
      f = function(socket, cb){
        return socket.write(data, cb);
      };
      return async.each(this.sockets, f, function(err){
        if (err != null) {
          ERR("failed to write data to data-server, err: " + err);
        }
        if (callback != null) {
          return callback(err);
        }
      });
    };
    prototype.addListener = function(evt, listener){
      return this.ee.addListener(evt, listener);
    };
    prototype.onData = function(c, buffer){
      return this.ee.emit('data', c, buffer);
    };
    prototype.onConnect = function(c){
      var self, end, incoming;
      self = this;
      INFO("incoming a connection: " + c.remoteAddress.yellow);
      end = function(){
        return self.onDisconnect.call(self, c);
      };
      incoming = function(buffer){
        return self.onData.call(self, c, buffer);
      };
      c.on('end', end);
      c.on('close', end);
      c.on('data', incoming);
      return this.sockets.push(c);
    };
    prototype.onDisconnect = function(c){
      var sockets, found, i$, len$, results$ = [];
      sockets = this.sockets;
      found = false;
      for (i$ = 0, len$ = this.sockets.length; i$ < len$; ++i$) {
        results$.push((fn$.call(this, i$, this.sockets[i$])));
      }
      return results$;
      function fn$(i, s){
        if (!found) {
          if (c === s) {
            sockets.splice(i, 1);
            found = true;
            return INFO("data_srv[" + i + "] disconnected and removed");
          }
        }
      }
    };
    return BaseServer;
  }());
  DataServer = (function(superclass){
    var prototype = extend$((import$(DataServer, superclass).displayName = 'DataServer', DataServer), superclass).prototype, constructor = DataServer;
    function DataServer(port){
      this.port = port;
      return DataServer.superclass.call(this, port);
    }
    return DataServer;
  }(BaseServer));
  MonitorServer = (function(superclass){
    var prototype = extend$((import$(MonitorServer, superclass).displayName = 'MonitorServer', MonitorServer), superclass).prototype, constructor = MonitorServer;
    function MonitorServer(port, alignments, remote_address){
      this.port = port;
      this.alignments = alignments;
      this.remote_address = remote_address;
      return MonitorServer.superclass.call(this, port);
    }
    prototype.prefix = function(time_str, to_remote){
      var t0;
      t0 = to_remote
        ? "<-".black.bgGreen
        : "->".black.bgWhite;
      return time_str.cyan + " " + this.remote_address.underline + " [" + t0 + "]";
    };
    prototype.format_buffer = function(time_str, hex_array, char_array, to_remote){
      var t1, t2;
      t1 = sprintf("%-" + this.alignments * 3 + "s", hex_array.join(" "));
      t2 = char_array.join("");
      return this.prefix(time_str, to_remote) + " " + t1.gray + " | " + t2;
    };
    prototype.restLines = function(){
      return this.output_lines = [];
    };
    prototype.addLine = function(line){
      return this.output_lines.push(line);
    };
    prototype.flushLines = function(cb){
      var text;
      this.output_lines.push("");
      text = this.output_lines.join("\r\n");
      return this.writeAll(text, cb);
    };
    prototype.output_buffer = function(data, to_remote, cb){
      var alignments, time_str, hex_array, char_array, count, i$, len$, b, t, c;
      alignments = this.alignments;
      time_str = moment().format('YYYY/MM/DD hh:mm:ss');
      hex_array = [];
      char_array = [];
      count = 0;
      this.restLines();
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        b = data[i$];
        count = count + 1;
        t = b < 16
          ? "0" + b.toString(16)
          : b.toString(16);
        c = b >= 0x20 && b < 0x7F
          ? String.fromCharCode(b)
          : " ".bgWhite;
        if (b === '\t'.charCodeAt()) {
          c = "t".bgMagenta.cyan.underline;
        }
        if (b === '\n'.charCodeAt()) {
          c = "n".bgMagenta.cyan.underline;
        }
        if (b === '\r'.charCodeAt()) {
          c = "r".bgMagenta.cyan.underline;
        }
        hex_array.push(t.toUpperCase());
        char_array.push(c);
        if (count >= alignments) {
          count = 0;
          this.addLine(this.format_buffer(time_str, hex_array, char_array, to_remote));
          hex_array = [];
          char_array = [];
        }
      }
      if (hex_array.length > 0) {
        this.addLine(this.format_buffer(time_str, hex_array, char_array, to_remote));
      }
      this.addLine(this.prefix(time_str, to_remote) + " " + data.length + " bytes");
      return this.flushLines(cb);
    };
    prototype.to_remote = function(data, cb){
      return this.output_buffer(data, true, cb);
    };
    prototype.from_remote = function(data, cb){
      return this.output_buffer(data, false, cb);
    };
    return MonitorServer;
  }(BaseServer));
  main = function(){
    var opt, arg, log_level, log_opts, logger, monitor, data_srv;
    opt = optimist.usage('Usage: $0').alias('r', 'remote').describe('r', 'the remote destination server, e.g. 192.168.0.2:8080').alias('l', 'listen').describe('l', 'listening port for data transmission, e.g. -l 8000').alias('m', 'monitor').describe('m', 'listening port for data monitoring, e.g. -m 8010').alias('v', 'verbose').describe('v', 'show more verbose messages').boolean(['h', 'v']).demand(['r', 'l', 'm']);
    arg = global.argv = opt.argv;
    if (global.argv.h) {
      opt.showHelp();
      process.exit(0);
    }
    log_level = arg.v ? 'debug' : 'info';
    log_opts = {
      name: 'tcp-proxy',
      serializers: bunyanDebugStream.serializers,
      streams: [{
        level: log_level,
        type: 'raw',
        stream: bunyanDebugStream({
          out: process.stderr,
          showProcess: false,
          colors: {
            debug: 'gray',
            info: 'white'
          }
        })
      }]
    };
    logger = global.logger = bunyan.createLogger(log_opts);
    DBG("remote = " + arg.r);
    DBG("listen = " + arg.l);
    DBG("monitor = " + arg.m);
    monitor = global.monitor = new MonitorServer(arg.m, 16, arg.r);
    data_srv = global.data_srv = new DataServer(arg.l);
    data_srv.addListener('data', function(c, buffer){
      data_srv.writeAll(buffer);
      return monitor.to_remote(buffer, function(e0){
        if (e0 != null) {
          return ERR("failed to send data to_remote(): " + e0);
        }
        INFO("success to_remote()");
        return monitor.from_remote(buffer, function(e1){
          if (e1 != null) {
            return ERR("failed to send data from_remote(): " + e1);
          }
          return INFO("success from_remote()");
        });
      });
    });
    data_srv.startup();
    return monitor.startup();
  };
  main();
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
