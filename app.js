// Generated by LiveScript 1.2.0
(function(){
  var net, events, url, colors, optimist, bunyan, bunyanDebugStream, async, moment, byline, sprintf, elemIndex, OPT, CHECK_INTERVAL, DBG, INFO, ERR, EXIT, RemoteClient, BaseServer, DataServer, DataFormatter, MonitorServer, main;
  net = require('net');
  events = require('events');
  url = require('url');
  colors = require('colors');
  optimist = require('optimist');
  bunyan = require('bunyan');
  bunyanDebugStream = require('bunyan-debug-stream');
  async = require('async');
  moment = require('moment');
  byline = require('byline');
  sprintf = require('sprintf-js').sprintf;
  elemIndex = require('prelude-ls').elemIndex;
  OPT = optimist.usage('Usage: $0').alias('r', 'remote').describe('r', 'the remote destination server, e.g. tcp:/192.168.0.2:8080, or just a port number to local server such as 10034').alias('l', 'listen').describe('l', 'listening port for data transmission, e.g. -l 8000')['default']('l', 8000).alias('m', 'monitor').describe('m', 'listening port for data monitoring, e.g. -m 8010')['default']('m', 8010).alias('v', 'verbose').describe('v', 'show more verbose messages').alias('p', 'protocol').describe('p', 'show line protocol verbose messages')['default']('p', false).boolean(['h', 'v', 'p']).demand(['r', 'l', 'm']);
  CHECK_INTERVAL = 2000;
  DBG = function(){
    return global.logger.debug.apply(global.logger, arguments);
  };
  INFO = function(){
    return global.logger.info.apply(global.logger, arguments);
  };
  ERR = function(){
    return global.logger.error.apply(global.logger, arguments);
  };
  EXIT = function(msg){
    ERR(msg);
    return process.exit(127);
  };
  RemoteClient = (function(){
    RemoteClient.displayName = 'RemoteClient';
    var prototype = RemoteClient.prototype, constructor = RemoteClient;
    function RemoteClient(url_tokens, monitor, line_proto){
      this.url_tokens = url_tokens;
      this.monitor = monitor;
      this.line_proto = line_proto != null ? line_proto : false;
      this.connected = false;
      this.client = null;
      this.checkObject = null;
      this.ee = new events.EventEmitter();
      this.line_stream = null;
    }
    prototype.addListener = function(evt, listener){
      return this.ee.addListener(evt, listener);
    };
    prototype.write = function(data, cb){
      var monitor;
      monitor = this.monitor;
      if (!this.connected) {
        return cb(this.url_tokens.host + " disconnected!!");
      }
      return this.client.write(data, function(err){
        if (err != null) {
          return cb(err);
        }
        return monitor.to_remote(data, cb);
      });
    };
    prototype.startup = function(cb){
      var self, check;
      self = this;
      this.startConnection();
      check = function(){
        return self.onCheck.apply(self, []);
      };
      this.checkObject = setInterval(check, CHECK_INTERVAL);
      return cb();
    };
    prototype.startConnection = function(){
      var self, ref$, host, hostname, port;
      self = this;
      ref$ = this.url_tokens, host = ref$.host, hostname = ref$.hostname, port = ref$.port;
      this.client = new net.Socket();
      this.client.on('error', function(err){
        return self.onError.apply(self, [err]);
      });
      this.client.on('close', function(){
        return self.onClosed.apply(self, []);
      });
      this.client.on('data', function(data){
        return self.onData.apply(self, [data]);
      });
      this.client.connect(port, hostname, function(){
        return self.onConnected.apply(self, []);
      });
      if (this.line_proto) {
        this.line_stream = byline(this.client);
        this.line_stream.on('data', function(line){
          return self.onLine.apply(self, [line]);
        });
      }
      return INFO("trying to connect to " + hostname + ":" + port);
    };
    prototype.onCheck = function(){
      if (this.client == null && !this.connected) {
        return this.startConnection();
      }
    };
    prototype.onError = function(err){
      var ref$, host, hostname, port;
      ref$ = this.url_tokens, host = ref$.host, hostname = ref$.hostname, port = ref$.port;
      ERR("failed to connect " + host.yellow + ", err: " + err);
      return this.cleanup();
    };
    prototype.onData = function(data){
      return this.ee.emit('data', data);
    };
    prototype.onLine = function(line){
      var ee;
      ee = this.ee;
      return setImmediate(function(){
        return ee.emit('line', line);
      });
    };
    prototype.onConnected = function(){
      var self, ref$, host, hostname, port;
      self = this;
      ref$ = this.url_tokens, host = ref$.host, hostname = ref$.hostname, port = ref$.port;
      INFO("connected to " + host.yellow + ":" + port.green);
      return this.connected = true;
    };
    prototype.onClosed = function(){
      var ref$, host, hostname, port;
      ref$ = this.url_tokens, host = ref$.host, hostname = ref$.hostname, port = ref$.port;
      INFO("disconnected from " + host.yellow + ":" + port.green);
      return this.cleanup();
    };
    prototype.cleanup = function(){
      if (this.line_stream != null) {
        this.line_stream.removeAllListeners('data');
        this.line_stream = null;
      }
      if (this.client != null) {
        this.client.removeAllListeners('data');
        this.client.removeAllListeners('error');
        this.client.removeAllListeners('close');
        this.client = null;
      }
      return this.connected = false;
    };
    return RemoteClient;
  }());
  BaseServer = (function(){
    BaseServer.displayName = 'BaseServer';
    var prototype = BaseServer.prototype, constructor = BaseServer;
    function BaseServer(port, line_proto){
      this.port = port;
      this.line_proto = line_proto != null ? line_proto : false;
      this.name = 'base';
      this.sockets = [];
      this.ee = new events.EventEmitter();
    }
    prototype.startup = function(cb){
      var self, port, name, connectCB, opts, server;
      self = this;
      port = this.port, name = this.name;
      connectCB = function(){
        return self.onConnect.apply(self, arguments);
      };
      opts = {
        allowHalfOpen: false,
        pauseOnConnect: false
      };
      server = this.server = net.createServer(opts, connectCB);
      return server.listen(port, function(err){
        var p;
        p = port + "";
        if (err == null) {
          INFO("listening " + p.green + " for " + name.cyan);
        }
        return cb(err);
      });
    };
    prototype.writeAll = function(data, cb){
      var f;
      f = function(socket, callback){
        return socket.write(data, callback);
      };
      return async.each(this.sockets, f, function(err){
        if (err != null) {
          ERR("failed to write data to data-server, err: " + err);
        }
        if (cb != null) {
          return cb(err);
        }
      });
    };
    prototype.addListener = function(evt, listener){
      return this.ee.addListener(evt, listener);
    };
    prototype.onData = function(c, buffer){
      return this.ee.emit('data', c, buffer);
    };
    prototype.onLine = function(c, line){
      var ee;
      ee = this.ee;
      return setImmediate(function(){
        return ee.emit('line', c, line);
      });
    };
    prototype.onConnect = function(c){
      var name, self, ls;
      name = this.name;
      self = this;
      INFO("[" + name.cyan + "] incoming a connection: " + c.remoteAddress.yellow);
      c.on('end', function(){
        return self.onDisconnect.call(self, c);
      });
      c.on('close', function(){
        return self.onDisconnect.call(self, c);
      });
      c.on('data', function(buffer){
        return self.onData.call(self, c, buffer);
      });
      if (this.line_proto) {
        ls = c.line_stream = byline(c);
        ls.on('data', function(line){
          return self.onLine.apply(self, [c, line]);
        });
      }
      return this.sockets.push(c);
    };
    prototype.onDisconnect = function(c){
      var sockets, found, i$, len$, results$ = [];
      sockets = this.sockets;
      if (this.line_proto) {
        c.line_stream.removeAllListeners('data');
        c.line_stream = null;
      }
      c.removeAllListeners('data');
      c.removeAllListeners('close');
      c.removeAllListeners('end');
      found = false;
      for (i$ = 0, len$ = this.sockets.length; i$ < len$; ++i$) {
        results$.push((fn$.call(this, i$, this.sockets[i$])));
      }
      return results$;
      function fn$(i, s){
        if (!found) {
          if (c === s) {
            sockets.splice(i, 1);
            found = true;
            return INFO("data_srv[" + i + "] disconnected and removed");
          }
        }
      }
    };
    return BaseServer;
  }());
  DataServer = (function(superclass){
    var prototype = extend$((import$(DataServer, superclass).displayName = 'DataServer', DataServer), superclass).prototype, constructor = DataServer;
    function DataServer(port, monitor, line_proto){
      this.port = port;
      this.monitor = monitor;
      DataServer.superclass.call(this, port, line_proto);
      this.name = 'data-srv';
    }
    prototype.writeAll = function(data, cb){
      var monitor;
      monitor = this.monitor;
      return superclass.prototype.writeAll.call(this, data, function(err){
        if (err != null) {
          return cb(err);
        }
        return monitor.from_remote(data, cb);
      });
    };
    return DataServer;
  }(BaseServer));
  DataFormatter = (function(){
    DataFormatter.displayName = 'DataFormatter';
    var prototype = DataFormatter.prototype, constructor = DataFormatter;
    function DataFormatter(alignments, remote_tokens){
      this.alignments = alignments;
      this.remote_tokens = remote_tokens;
      this.counter = 0;
    }
    prototype.padding = function(num){
      var t0, char_array, i$, to$, i;
      t0 = num + "";
      char_array = [];
      for (i$ = 1, to$ = 6 - t0.length; i$ <= to$; ++i$) {
        i = i$;
        char_array.push("0");
      }
      char_array.push(t0);
      return char_array.join("");
    };
    prototype.prefix = function(time_str, to_remote){
      var t0;
      t0 = to_remote
        ? "<-".black.bgRed
        : "->".black.bgWhite;
      return time_str.cyan + " " + this.remote_tokens.hostname.underline + ":" + this.remote_tokens.port.green + " (" + this.padding(this.counter) + ") [" + t0 + "]";
    };
    prototype.format_buffer = function(hex_array, char_array){
      var t1, t2;
      t1 = sprintf("%-" + this.alignments * 3 + "s", hex_array.join(" "));
      t2 = char_array.join("");
      return t1.yellow + " | " + t2;
    };
    prototype.restLines = function(to_remote){
      var time_str;
      time_str = moment().format('MM/DD hh:mm:ss');
      this.prefix_str = this.prefix(time_str, to_remote);
      return this.output_lines = [];
    };
    prototype.addLine = function(line){
      return this.output_lines.push(this.prefix_str + " " + line);
    };
    prototype.format_bytes = function(data, to_remote){
      var alignments, hex_array, char_array, count, i$, len$, b, t, c;
      this.counter = this.counter + 1;
      alignments = this.alignments;
      hex_array = [];
      char_array = [];
      count = 0;
      this.restLines(to_remote);
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        b = data[i$];
        count = count + 1;
        t = b < 16
          ? "0" + b.toString(16)
          : b.toString(16);
        c = b >= 0x20 && b < 0x7F
          ? String.fromCharCode(b)
          : " ".bgWhite;
        if (b === '\t'.charCodeAt()) {
          c = "t".bgMagenta.cyan.underline;
        }
        if (b === '\n'.charCodeAt()) {
          c = "n".bgMagenta.cyan.underline;
        }
        if (b === '\r'.charCodeAt()) {
          c = "r".bgMagenta.cyan.underline;
        }
        hex_array.push(t.toUpperCase());
        char_array.push(c);
        if (count >= alignments) {
          count = 0;
          this.addLine(this.format_buffer(hex_array, char_array));
          hex_array = [];
          char_array = [];
        }
      }
      if (hex_array.length > 0) {
        this.addLine(this.format_buffer(hex_array, char_array));
      }
      if (global.argv.v) {
        this.addLine((data.length + " bytes").gray);
      }
      this.output_lines.push("");
      return this.output_lines.join("\r\n");
    };
    prototype.format_line = function(line, to_remote){
      var char_array, i$, len$;
      this.counter = this.counter + 1;
      this.restLines(to_remote);
      char_array = [];
      for (i$ = 0, len$ = line.length; i$ < len$; ++i$) {
        (fn$.call(this, i$, line[i$]));
      }
      this.addLine(char_array.join(""));
      this.output_lines.push("");
      return this.output_lines.join("\r\n");
      function fn$(i, c){
        var x;
        x = c >= 0x20 && c < 0x7F
          ? String.fromCharCode(c)
          : " ".bgWhite;
        if (c === '\t'.charCodeAt()) {
          x = " " + '\\t'.blue.bgGreen + " ";
        }
        if (c === '\r'.charCodeAt()) {
          x = "r".bgMagenta.cyan.underline;
        }
        if (c === '\n'.charCodeAt()) {
          x = "n".bgMagenta.cyan.underline;
        }
        char_array.push(x);
      }
    };
    return DataFormatter;
  }());
  MonitorServer = (function(superclass){
    var prototype = extend$((import$(MonitorServer, superclass).displayName = 'MonitorServer', MonitorServer), superclass).prototype, constructor = MonitorServer;
    function MonitorServer(port, alignments, remote_tokens){
      this.port = port;
      this.alignments = alignments;
      this.remote_tokens = remote_tokens;
      MonitorServer.superclass.call(this, port);
      this.name = 'monitor';
      this.df = new DataFormatter(alignments, remote_tokens);
    }
    prototype.output_buffer = function(data, to_remote, cb){
      var text;
      text = this.df.format_bytes(data, to_remote);
      return this.writeAll(text, cb);
    };
    prototype.output_line = function(line, to_remote, cb){
      var text;
      text = this.df.format_line(line, to_remote);
      return this.writeAll(text, cb);
    };
    prototype.to_remote = function(data, cb){
      return this.output_buffer(data, true, cb);
    };
    prototype.from_remote = function(data, cb){
      return this.output_buffer(data, false, cb);
    };
    prototype.to_remote_line = function(line, cb){
      return this.output_line(line, true, cb);
    };
    prototype.from_remote_line = function(line, cb){
      return this.output_line(line, false, cb);
    };
    return MonitorServer;
  }(BaseServer));
  main = function(){
    var argv, log_level, log_opts, logger, url_tokens, monitor, data_srv, client, s;
    argv = global.argv = OPT.argv;
    if (global.argv.h) {
      opt.showHelp();
      process.exit(0);
    }
    log_level = argv.v ? 'debug' : 'info';
    log_opts = {
      name: 'tcp-proxy',
      serializers: bunyanDebugStream.serializers,
      streams: [{
        level: log_level,
        type: 'raw',
        stream: bunyanDebugStream({
          out: process.stderr,
          showProcess: false,
          colors: {
            debug: 'gray',
            info: 'white'
          }
        })
      }]
    };
    logger = global.logger = bunyan.createLogger(log_opts);
    if ('number' === typeof argv.r) {
      argv.r = "tcp://127.0.0.1:" + argv.r;
    }
    DBG("remote = " + argv.r + ", listen = " + argv.l + ", monitor = " + argv.m);
    url_tokens = url.parse(argv.r);
    DBG("url_tokens.protocol = " + url_tokens.protocol);
    if (elemIndex(url_tokens.protocol, ['tcp:', 'ssl:']) == null) {
      EXIT("invalid protocol " + url_tokens.protocol.red + " for remote destination server");
    }
    monitor = new MonitorServer(argv.m, 16, url_tokens);
    data_srv = new DataServer(argv.l, monitor, argv.p);
    client = new RemoteClient(url_tokens, monitor, argv.p);
    data_srv.addListener('data', function(c, data){
      return client.write(data, function(err){
        if (err != null) {
          return ERR("failed to send " + data.length + " bytes (from " + c.remoteAddress + ") to remote server, err: " + err);
        }
        return DBG("successfully send " + data.length + " bytes to remote. (from " + c.remoteAddress + ")");
      });
    });
    data_srv.addListener('line', function(c, line){
      return monitor.to_remote_line(line, function(err){
        if (err != null) {
          return ERR("failed to dump a line (" + line.length + " bytes) sending to remote, err: " + err);
        }
        return DBG("successfully dump a line (" + line.length + " bytes) sending to remote");
      });
    });
    client.addListener('line', function(line){
      return monitor.from_remote_line(line, function(err){
        if (err != null) {
          return ERR("failed to dump a line (" + line.length + " bytes) receiving from remote, err: " + err);
        }
        return DBG("successfully dump a line (" + line.length + " bytes) receiving from remote");
      });
    });
    client.addListener('data', function(data){
      return data_srv.writeAll(data, function(err){
        if (err != null) {
          return ERR("failed to send " + data.length + " bytes to local connections, err: " + err);
        }
        return DBG("successfully send " + data.length + " bytes to local connections");
      });
    });
    s = function(srv, cb){
      return srv.startup(cb);
    };
    return async.each([monitor, data_srv, client], s, function(err){
      if (err != null) {
        EXIT("failed to startup all services, err: " + err);
      }
      return INFO("server is ready".yellow);
    });
  };
  main();
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
